/**
 * @file tb_ssr_multistage_decimator.cpp
 * @brief Testbench for the ssr multistage decimator.
 *
 * Detailed explanation about what this file contains or does.
 *
 * @author marco.pausini@gmail.com
 * @date 2023-11-xy
 * @version 0.1
 *
 */

#include <fstream>
#include <iostream>
#include <cstdio>
#include <vector>
#include <string>
#include <sstream>
#include <iomanip>

#include "../src/ssr_multistage_decimator.h"

// ANSI escape codes for setting text colors
const std::string GREEN = "\033[32m";
const std::string YELLOW = "\033[33m";
const std::string RED = "\033[31m";
const std::string RESET = "\033[0m";

// ---------------------------------------
// ssr_multistage_decimator data interface
// ---------------------------------------
struct dataInputInterface_t
{
    bool tvalid;              // input data valid
    cdatain_vec_t<ssr> tdata; // input sample
};
struct dataOutputInterface_t
{
    bool tvalid;               // data valid
    cdataout_vec_t<ssr> tdata; // output samples
};

// Function prototype.
void readParameterFile(std::ifstream &parameterFile, dec_factor_t &dec_factor);
// void parseInputLine(std::string &inputLine, dataInputInterface_t &din);
void writeOutput(std::ofstream &outputFile, const dataOutputInterface_t &dout, const size_t ssr);

int main(void)
{
    std::cout << GREEN << "-----------------------------------------" << RESET << std::endl;
    std::cout << GREEN << "- SSR Multistage Decimator Testbench    -" << RESET << std::endl;
    std::cout << GREEN << "-----------------------------------------" << RESET << std::endl;

    // -----------------------------------------------------
    // Testbench I/O files: Input files generated by Matlab:
    // -----------------------------------------------------
    // Parameters file
    std::ifstream parameterFile("work/parameters.csv");
    // Simulation input file (generated by Matlab)
    std::ifstream inputFile("work/input_test_vector.txt");
    // reference output files
    // std::ifstream goldenFile("work/output.txt");

    // -----------------------------------------------------------------
    // Testbench I/O files: Output files generated by the C-Simulation
    // -----------------------------------------------------------------
    // log the input to verify the testbench inputing the data correctly
    std::ofstream logInputFile("work/log_input_test_vector.txt");
    // file with ouput data (each line is a clock cycle)
    std::ofstream outputFile("work/output_csim.txt");

    // Check if the file is open
    if (!parameterFile.is_open())
    {
        std::cerr << "Error: could not open the paramaters file " << std::endl;
        return 1;
    }
    if (!inputFile.is_open())
    {
        std::cerr << "Error: could not open the input file." << std::endl;
        return 1;
    }
    if (!logInputFile.is_open())
    {
        std::cerr << "Error: could not open the log input file." << std::endl;
        return 1;
    }
    if (!outputFile.is_open())
    {
        std::cerr << "Error: could not open the output file." << std::endl;
        return 1;
    }

    // ----------------------------
    // Testbench variables
    // ----------------------------

    // number of simulation input samples
    int numInputSamples = 0;
    // count number of output samples
    int numOutputSamples = 0;

    // number of clocks to wait before start sending the input samples
    int numClkWait = 10;

    // ------------------------------------
    // ssr_multistage_decimator I/O ports
    // ------------------------------------

    // Decimation factor
    dec_factor_t dec_factor = 1;

    struct dataInputInterface_t din = {
        .tvalid = false,
        .tdata = {0xBBBB, 0xAAAA}};

    struct dataOutputInterface_t dout;

    // ---------------------------------------------------------
    // Wait some clocks before start interacting with the DUT
    // ---------------------------------------------------------
    std::cout << "Waiting " << numClkWait << " clocks before start interacting with the DUT..." << std::endl;
    for (int i = 0; i < numClkWait; ++i)
    {
        // logInput(logInputFile, dec_factor, din);
        ssr_multistage_decimator(dec_factor, din.tvalid, din.tdata, dout.tvalid, dout.tdata);
        writeOutput(outputFile, dout, ssr);
    }

    // --------------------------------------
    // Configure the ssr_multistage_decimator
    // --------------------------------------

    // Read the parameters file
    readParameterFile(parameterFile, dec_factor);
    //
    ssr_multistage_decimator(dec_factor, din.tvalid, din.tdata, dout.tvalid, dout.tdata);
    writeOutput(outputFile, dout, ssr);

    std::cout << "Waiting some more " << numClkWait << " clocks before sending data ..." << std::endl;
    for (int i = 0; i < numClkWait; ++i)
    {
        ssr_multistage_decimator(dec_factor, din.tvalid, din.tdata, dout.tvalid, dout.tdata);
        writeOutput(outputFile, dout, ssr);
    }

    // ------------------------------------
    // variables to control the simulation
    // ------------------------------------
    // flags to control the loop
    bool endOfInputSamples = false;
    bool tapDelayLineFlushed = false;

    // counters
    int watchdogCounter = 0;
    int tapDelayLineCounter = 100; // to be checked
    int watchdogLimit = 10000;

    // --------------------------------
    // Start the decimation process
    // -------------------------------
    std::cout << "Send input samples..." << std::endl;

    // Read the input test vector file line by line
    std::string line;

    // loop over the input test vector file
    while ((std::getline(inputFile, line) || !tapDelayLineFlushed))
    {
        if (!line.empty())
        {
            std::istringstream iss(line);
            int re, im;
            for (size_t i = 0; i < ssr; ++i)
            {
                if (!(iss >> re >> im))
                {
                    std::cerr << "Error: failed to parse input." << std::endl;
                    // Handle the error appropriately here
                    continue; // For example, skip the rest of this iteration
                }
                din.tdata.re[i].range() = re;
                din.tdata.im[i].range() = im;
            }
           // std::cout << "din.tdata.re[0] = " << din.tdata.re[0] << std::endl;
            din.tvalid = true;
            numInputSamples += ssr;
        }
        else
        {
            if (tapDelayLineCounter > 0)
            {
                tapDelayLineCounter--;
            }
            else
            {
                tapDelayLineFlushed = true;
            }
            din.tvalid = false;
        }

        // send data
        ssr_multistage_decimator(dec_factor, din.tvalid, din.tdata, dout.tvalid, dout.tdata);



        if (dout.tvalid)
        {
         
            //std::cout << "dout.tdata.re[0] = " << dout.tdata.re[0] << std::endl;
            // increment the number of output samples
            switch (dec_factor)
            {
            case 1:
                numOutputSamples = numOutputSamples + ssr;
                break;
            case 2:
                numOutputSamples = numOutputSamples + ssr / 2;
                break;
            case 4: 
                numOutputSamples = numOutputSamples + ssr / 4;
                break;
            case 8:
            case 16:
            case 32:
            case 64:    
                numOutputSamples = numOutputSamples + ssr / 8;
                break;
            default:
                break;
            }
        }
        writeOutput(outputFile, dout, ssr);
    }

    // ---------------------------------
    // Simulation results
    // ---------------------------------

    std::cout << std::left; // Align all columns to the left
    // Print header with setw for alignment
    std::cout << std::setw(25) << "numSamplesInput"
              << std::setw(25) << "numSamplesOutput" << std::endl;

    // Output a row of data
    std::cout
              << std::setw(25) << numInputSamples
              << std::setw(25) << numOutputSamples
              << std::endl;

    return 0;
}

void readParameterFile(std::ifstream &parameterFile, dec_factor_t &dec_factor)
{
    // Read the file line by line
    std::string line;
    while (std::getline(parameterFile, line))
    {
        // Skip empty lines
        if (line.empty())
            continue;
        // Skip comments
        if (line[0] == '#')
            continue;
        // First value is the decimation factor
        dec_factor = std::stoi(line);
        // Print the read values
        std::cout << "Decimation factor: " << dec_factor << std::endl;
    }
}

void writeOutput(std::ofstream &outputFile, const dataOutputInterface_t &dout, const size_t ssr)
{

    outputFile << std::setw(4) << dout.tvalid << " ";

    // Cast to fixed point integer and write the output to file
    for (size_t i = 0; i < ssr; ++i)
    {
        // Cast to fixed point integer
        ap_int<dataout_bits> out_re = dout.tdata.re[i].range();
        ap_int<dataout_bits> out_im = dout.tdata.im[i].range();

        outputFile << std::setw(6) << out_re << " ";
        outputFile << std::setw(6) << out_im;
        if (i < ssr - 1)
        {
            outputFile << " "; // Add space between numbers except after the last one
        }
    }
    outputFile << std::endl;
}